<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jboss | Harald Pehl]]></title>
  <link href="http://hpehl.info/blog/categories/jboss/atom.xml" rel="self"/>
  <link href="http://hpehl.info/"/>
  <updated>2015-06-07T16:38:39+02:00</updated>
  <id>http://hpehl.info/</id>
  <author>
    <name><![CDATA[Harald Pehl]]></name>
    <email><![CDATA[harald.pehl@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JDBC Driver Setup]]></title>
    <link href="http://hpehl.info/jdbc-driver-setup.html"/>
    <updated>2015-06-07T16:20:00+02:00</updated>
    <id>http://hpehl.info/jdbc-driver-setup</id>
    <content type="html"><![CDATA[<p>The installation of JDBC drivers and the setup of (xa)datasources is a common task for every JEE developer and administrator. This post describes the installation and setup of a MySQL driver and datasource using WildFly 9 in both standalone and domain mode. If you use another database, you'll probably go through the same steps, but using different parameters.<!-- more --></p>

<p> When installing a driver you basically have two options: install it as module or deploy it like any other application package. However when running domain mode you should choose to install the driver as module. Otherwise the driver won't be recognized by the <code>:installed-drivers-list</code> operation. Drivers deployed as application packages need a running server, which cannot be guaranteed in domain mode. Thus the recommendation is to <em>always</em> use the module option in domain mode. For standalone mode you are free to choose between module and deployment since both options will work.</p>

<h1>Install as Module</h1>

<ol>
<li>Download the driver from the <a href="https://dev.mysql.com/downloads/connector/j/">MySQL website</a></li>
<li>Go to <code>WILDFLY_HOME/modules/system/layers/base/com</code> and create the folder <code>mysql/main</code></li>
<li>Unzip the downloaded file and copy the file <code>mysql-connector-java-5.1.23-bin.jar</code> to the new folder <code>WILDFLY_HOME/modules/system/layers/base/com/mysql/main</code></li>
<li>Create the file <code>module.xml</code> in the same folder with the following content:</li>
</ol>


<p>```xml
<module xmlns="urn:jboss:module:1.3" name="com.mysql"></p>

<pre><code>&lt;resources&gt;
    &lt;resource-root path="mysql-connector-java-5.1.35-bin.jar"/&gt;
&lt;/resources&gt;
&lt;dependencies&gt;
    &lt;module name="javax.api"/&gt;
    &lt;module name="javax.transaction.api"/&gt;
&lt;/dependencies&gt;
</code></pre>

<p></module>
```</p>

<p>The name of the driver file may vary, so make sure you declare exactly the same name in the <code>resource-root</code> tag. After restarting WildFly the module is available and can be referenced to create a JDBC driver. Open the CLI and execute the following command for standalone mode:</p>

<p>```
[standalone@localhost:9990 /] /subsystem=datasources/jdbc-driver=mysql:add(\</p>

<pre><code>driver-name=mysql,\
driver-module-name=com.mysql,\
driver-class-name=com.mysql.jdbc.Driver,\
driver-xa-datasource-class-name=com.mysql.jdbc.jdbc2.optional.MysqlXADataSource\
</code></pre>

<p>)
```</p>

<p>and this command if you're using domain mode:</p>

<p>```
[domain@localhost:9990 /] /profile=full/subsystem=datasources/jdbc-driver=mysql:add(\</p>

<pre><code>driver-name=mysql,\
driver-module-name=com.mysql,\
driver-class-name=com.mysql.jdbc.Driver,\
driver-xa-datasource-class-name=com.mysql.jdbc.jdbc2.optional.MysqlXADataSource\
</code></pre>

<p>)
```</p>

<h1>Install as Deployment</h1>

<p>Please note that this option is only valid for JDBC4 compliant drivers. For none JDBC4 compliant drivers you should install the driver as a module. Furthermore it's not recommended for the domain mode.</p>

<ol>
<li>Download the driver from the <a href="https://dev.mysql.com/downloads/connector/j/">MySQL website</a></li>
<li>Unzip the downloaded file and deploy and enable the file <code>mysql-connector-java-5.1.23-bin.jar</code></li>
</ol>


<p>The contained JDBC drivers will be automatically detected and registered (no need to execute additional management operations).</p>

<h1>Setup a Datasource</h1>

<p>In order to setup a datasource open the management console and navigate to "Configuration / (Profile ...) / Datasources" and click "Add" to bring up the wizard for creating a (XA) datasource. The console already contains templates for the most common databases. The templates combine settings like connection url, validation checker and exception sorter implementations. Choose "MySQL Datasource" and adjust the settings as necessary. You should see the JDBC driver you've installed as module or deployment in the "JDBC Driver" step under "Detected Driver".  Before you exit the wizard you can test the connection using the button on the final step.</p>

<p>If you prefer to use the CLI to create the datasource use a command like this one (leave out <code>/profile=full</code> for standalone mode):</p>

<p>```
[domain@localhost:9990 /] /profile=full/subsystem=datasources/data-source=MySqlDS:add(\</p>

<pre><code>jndi-name=java:/MySqlDS,\
driver-name=mysql,\
connection-url=jdbc:mysql://localhost:3306/test
</code></pre>

<p>)
```</p>

<p>However please note that you have to configure database specific settings like validation checker et al by yourself.</p>

<h1>Use the Datasource</h1>

<p>When running domain mode, the datasource is always bound to a profile and thus accessible by servers which are part of a server group which in turn uses that profile.</p>

<p>To access the datasource in your JEE app, use the JNDI name. Here's an example of a JPA configuration:</p>

<p>```xml
<persistence-unit name="app-pu" transaction-type="JTA"></p>

<pre><code>&lt;jta-data-source&gt;java:/MySqlDS&lt;/jta-data-source&gt;
&lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;
&lt;properties/&gt;
</code></pre>

<p></persistence-unit>
```</p>

<p>and here an example for a resource injection:</p>

<p>```java
public class SomeClass {</p>

<pre><code>@Resource(name = "java:/MySqlDS")
private javax.sql.DataSource dataSource;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updated management console in WildFly 9]]></title>
    <link href="http://hpehl.info/updated-management-console-in-wildfly-9.html"/>
    <updated>2015-03-16T22:44:00+01:00</updated>
    <id>http://hpehl.info/updated-management-console-in-wildfly-9</id>
    <content type="html"><![CDATA[<p>The upcoming WildFly 9 release will include an improved HAL management console based on the <a href="https://github.com/hal/core/tree/2.6.x">2.6.x branch</a> branch.</p>

<p>The improvements at a glance:</p>

<ul>
<li>New subsystem configuration: Remoting</li>
<li>Support for datasource templates.</li>
<li>Provide all flush-* operations for connection pools</li>
<li>Improved log viewer</li>
<li>Enhanced model browser</li>
<li>Get more details about applied patches</li>
<li>Standalone console</li>
</ul>


<!-- More -->


<h1>Remoting subsystem</h1>

<p>The remoting subsystem was added to the console. You can now configure remote (http) connectors and outbound connections.</p>

<p><figure class="centered"><img src="/images/posts/remoting_subsystem.png" title="Remoting subsystem" ></figure></p>

<h1>Datasource Templates</h1>

<p>The management console provides for the datasource most commonly used templates with reasonable default settings. These presets include JNDI names, driver settings, datasource properties and highly specific options like validation checkers and exception sorters.</p>

<p><figure class="centered"><img src="/images/posts/datasource_templates.png" title="Datasource templates" ></figure></p>

<h1>Improved Log Viewer</h1>

<p>WildFly 8.2 featured a log viewer which allowed you to browse through or tail server logs. Now you can view the log file as a whole in the console and search for specific text. Optionally you can download the full log file and open it in an external editor of your choice.</p>

<p><figure class="centered"><img src="/images/posts/improved_log_viewer.png" title="Improved log viewer" ></figure></p>

<h1>Standalone Console</h1>

<p>Starting with WildFly 9 and <a href="http://hal.gitbooks.io/dev/content/release-coordination/versions/2.6.5.Final.html">HAL 2.6.5.Final</a> the management console can be launched independently from WildFly. Take a look at my <a href="/standalone-management-console.html">last post</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Standalone Management Console]]></title>
    <link href="http://hpehl.info/standalone-management-console.html"/>
    <updated>2015-03-16T16:00:00+01:00</updated>
    <id>http://hpehl.info/standalone-management-console</id>
    <content type="html"><![CDATA[<p>Back in 2013 I wrote about an idea to have an <a href="/independent-jboss-admin-console.html">independent management console</a> which can connect to arbitrary servers. Starting with WildFly 9 we finally have the technical prerequisites to ship such a console. In this blog post I will describe how to configure and launch an independent management console.<!-- more --></p>

<p>As you might know the management console is developed using GWT and compiles down to a bunch of HTML, JavaScript and CSS files. Until now these artifacts were a fixed module of each WildFly version. WildFly serves the console and the console talks to the same origin it was loaded from. This still holds true.</p>

<p>However starting with WildFly 9 the HTTP endpoint for the management interface supports the configuration of so-called allowed origins. This list - which is empty by default - contains URLs which are allowed to access the management interface (see http://en.wikipedia.org/wiki/Cross-origin_resource_sharing for more details). This setup is necessary to cope with the <a href="http://en.wikipedia.org/wiki/Same_origin_policy">same origin policy</a> (SOP) when the console is served from origin A, but talks to the management interface at origin B.</p>

<p>Equipped with these features we can now launch the management console from any URL and connect to any management interface which has this URL configured as an allowed origin. To make things simple, we've setup an <a href="http://access-halproject.rhcloud.com/">HAL build proxy</a> on OpenShift. This proxy is able to fetch any console version from the public JBoss maven repository and serve it using a distinct URL. It offers a list of simple HTTP endpoints:</p>

<ul>
<li><p><code>/latest</code><br/>
Displays the version of the latest HAL release<br/>
http://access-halproject.rhcloud.com/latest</p></li>
<li><p><code>/releases</code><br/>
Gets the list of supported HAL releases (w/o snapshots)<br/>
http://access-halproject.rhcloud.com/releases</p></li>
<li><p><code>/release/:version</code><br/>
Serves a specific HAL version (only works with version > 2.6.x)<br/>
http://access-halproject.rhcloud.com/release/2.6.5.Final</p></li>
<li><p><code>/snapshot/:version</code><br/>
Serves a specific HAL snapshot (only works with version > 2.6.x)<br/>
http://access-halproject.rhcloud.com//snapshot/2.7.0-SNAPSHOT</p></li>
</ul>


<p>If you don't want to use the prebuilt proxy on OpenShift, you can also checkout the source code and run your own build proxy:</p>

<ol>
<li>Clone the registry from https://github.com/hal/mvn-repo-server</li>
<li>Build the proxy with Maven: <code>mvn clean package</code> (requires Java 8)</li>
<li>Start the proxy: <code>java -jar target/server-jar-with-dependencies.jar</code> (by default port 8080 is used)</li>
<li>Open http://localhost:8080/</li>
</ol>


<h1>Allowed Origins Setup</h1>

<p>Whether you use the prebuilt proxy on OpenShift or build your own, you have to add the URL of the standalone console to the list of allowed origins. Depending on the operation mode use one of the following CLI commands:</p>

<ul>
<li><p>standalone mode:</p>

<pre><code>  /core-service=management/management-interface=http-interface:list-add(name=allowed-origins,value=http://access-halproject.rhcloud.com)
  reload
</code></pre></li>
<li><p>domain mode:</p>

<pre><code>  /host=master/core-service=management/management-interface=http-interface:list-add(name=allowed-origins,value=http://access-halproject.rhcloud.com)
  reload --host=master
</code></pre></li>
</ul>


<h1>Console Configuration</h1>

<p>When you open the console it detects whether it is part of a WildFly instance or launched independently. In the latter case you need to specify a management interface you like to connect to. You can manage a list of different interfaces running on different WildFly instances. The configuration is stored in the browser's local storage, so it's available the next time you open the console.</p>

<p>Say you want access your local WildFly instance using the HAL management console 2.6.5.Final served from the build proxy. In order to do so, follow these steps:</p>

<ol>
<li><p>Point your browser to http://access-halproject.rhcloud.com/release/2.6.5.Final</p></li>
<li><p>Click 'Add' to configure a management endpoint.<br/>
<img src="/images/posts/bootstrap_server_select_0.png" alt="Connect to Management Interface" /></p></li>
<li><p>Add the hostname and port of you local WildFly instance. You can verify your settings using 'Ping'.<br/>
<img src="/images/posts/bootstrap_server_select_1.png" alt="Connect to Management Interface" /></p></li>
<li><p>Click 'Connect' to finish.<br/>
<img src="/images/posts/bootstrap_server_select_2.png" alt="Connect to Management Interface" /></p></li>
</ol>


<p>You can use an existing configuration using the <code>connect</code> query parameter. For the above example this url is a shortcut and will skip the bootstrap dialogs: http://access-halproject.rhcloud.com/2.6.5.Final/App.html?connect=local</p>

<h1>Outlook</h1>

<p>In the future we'd like to use the new distribution model to provide different console versions with different feature sets (nightly, beta, stable). This gives us a way to share new features with the community as soon as possible and to get feedback earlier on.</p>

<h1>Limitations and Known Problems</h1>

<p>When using the standalone console there are some pitfalls and preconditions you should be aware of:</p>

<ul>
<li>The standalone console can only connect to WildFly 9.x and above.</li>
<li>Make sure to configure the allowed origins before connecting from the standalone console.</li>
<li>Don't use different schemes (https and http) for the standalone console and the WildFly instance you want to connect to.</li>
<li>In rare cases it might be necessary to clear the cache or use the browser's private mode when switching between different WildFly instances.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Local Search in the Management Console]]></title>
    <link href="http://hpehl.info/search_in_console.html"/>
    <updated>2014-11-21T10:21:00+01:00</updated>
    <id>http://hpehl.info/search_in_console</id>
    <content type="html"><![CDATA[<p>Today <a href="http://wildfly.org/news/2014/11/20/WildFly82-Final-Released/">WildFly 8.2.0.Final</a> was released. It comes with a number of improvements and bug fixes over the last release, 8.1.0.Final. Regarding the management console, Heiko Braun already gave a glimpse of some of new features in his recent <a href="http://hbraun.info/2014/10/updated-management-console-in-wildfly-8-2/">blog post</a>. Today I'd like to introduce yet another feature which was introduced in WildFyl 8.2: Local Search.<!-- more --></p>

<p>With every new feature added to WildFly, the number of screens and options in the management console grows as well. Sometimes it's hard to quickly find the right screen where you can modify your JMS topics or monitor that data source connection pool. That's why we added a search feature to the management console. It's built around the idea to have an index which contains reasonable keywords and the descriptions from the underlying <a href="http://wildscribe.github.io/">management model</a>.</p>

<p>It's super fast, because the index is built and stored locally inside the browser. That's why you need a modern browser with support for <a href="http://caniuse.com/#search=localstorage">local storage</a> to use the search. Don't worry about the size of the index, it's quite compact: For WildFly 8.2 running in domain mode the index will be roughly 10 KByte large, so it's no a big deal to keep the index in local storage. For those who want to know all the nitty-gritty details, the local search is based on the JavaScript framework <a href="http://lunrjs.com/">lunr.js</a>. In a nutshell lunr.js is slimmed full-text search engine ready to be used in your browser. But enough with all these implementation details. Let's see how this all works:</p>

<p>To enter the search press the search link in the upper right corner of the management console:</p>

<p><figure class="centered"><img src="/images/posts/local_search_header.png" title="Local Search" ></figure></p>

<p>The first time you enter the search, the index is automatically created based on the WildFly version, the operation mode (standalone or domain) and the language. During index creation the descriptions of the management model is fetched from the server side and stored in the index. Depending on your setup and network latency this make take a few seconds.</p>

<p><figure class="centered"><img src="/images/posts/local_search_index_setup.png" title="Indexing..." ></figure></p>

<p>Once the index is ready you can start searching. As you type your query the results will update dynamically:</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/wdb3W-G-9WI" frameborder="0" allowfullscreen></iframe>




<br/>


<p>Give the new local search a try and let us know what you think!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WildFly Dockerfiles]]></title>
    <link href="http://hpehl.info/wildfly-dockerfiles.html"/>
    <updated>2013-11-28T14:40:00+01:00</updated>
    <id>http://hpehl.info/wildfly-dockerfiles</id>
    <content type="html"><![CDATA[<p>For the last couple of days I have been playing with <a href="http://www.docker.io">Docker</a>. In a nutshell Docker is a tool
that lets you create images and run so called containers. It uses <a href="http://lxc.sourceforge.net/">Linux Containers</a> (LXC)
under the hood. What appears to be yet another virtualization solution, is in fact a very lightweight way to setup,
manage and run "processes in a box".<!-- more --></p>

<p>Docker comes with a great <a href="http://www.docker.io/gettingstarted/">tutorial</a> and a
reasonable <a href="http://docs.docker.io/en/latest/">documentation</a>. So I won't go into any details here. There are also some
very good <a href="http://goldmann.pl/blog/tags/docker/">posts</a> from <a href="http://goldmann.pl/blog/">Marek Goldmann</a> which helped
me a lot getting started. In the remaining part of this post I will show you how to setup both a WildFly standalone
server and a domain with multiple hosts and servers. Here we go!</p>

<h1>Preperations</h1>

<p>I assume you already have installed Docker. If not please refer to the
<a href="http://www.docker.io/gettingstarted/#h_installation">offical documentation</a> on how to setup Docker on your machine.
The following assumes you're using Docker 0.7.0.</p>

<p>I've put together a repository which is based on Ubuntu and contains Java7 and WildFly 8.0.0.Beta1. It does not contain
any commands or entrypoints, but is intended to serve as a base repository for the other WildFly related repositories.
You can grap it and use it as a starting point:</p>

<p><code>
$ docker pull hpehl/wildfly
$ docker run -i -t hpehl/wildfly /bin/bash
</code></p>

<h1>Standalone</h1>

<p>To quickly run a standalone server, I've put together the repository <code>hpehl/wildfly-standalone</code>. It is based on
<code>hpehl/wildfly</code> and starts an unmodified standalone server. The standalone server exposes the following ports:</p>

<ul>
<li>8080 for HTTP</li>
<li>9990 for HTTP based management and</li>
<li>9999 for native management</li>
</ul>


<p>You can use the user <code>admin:passw0rd_</code> to access the management interfaces. Running it with</p>

<p><code>
docker run -p 49080:8080 -p 49090:9990 -d hpehl/wildfly-standalone
</code></p>

<p>will start the server. You can check the status with <code>docker logs &lt;CONTAINER_ID&gt;</code>. After a short while you should
be able to access the server using http://localhost:49080</p>

<p><figure class="centered"><img src="/images/posts/docker_wildfly_standalone.png" title="WildFly standalone server running inside a Docker container" ></figure></p>

<h1>Domain</h1>

<p>To setup a domain use the repository <code>hpehl/wildfly-domain</code>. It contains different tags to start a domain controller
and up to four hosts. Tags are a way to reference different images inside a repository. The syntax for tags is
<code>&lt;repository&gt;:&lt;tag&gt;</code>. When no tag is given, Docker uses the tag <code>latest</code>. The domain repository consists of these tags:</p>

<ul>
<li><code>hpehl/wildfly-domain:dc</code>: The domain controller with five servers. The domain controller defines three server groups:

<ul>
<li>deployment</li>
<li>staging</li>
<li>production</li>
</ul>
</li>
<li><code>hpehl/wildfly-domain:hostA</code>: First host with three servers</li>
<li><code>hpehl/wildfly-domain:hostB</code>: Second host with three servers</li>
<li><code>hpehl/wildfly-domain:hostC</code>: Third host with two servers</li>
<li><code>hpehl/wildfly-domain:hostD</code>: Fourth host with two servers</li>
</ul>


<p>Docker has a great feature which enables inter-container communication. This is done by specifying the <code>link</code>
parameter. When linking two containers Docker will use the exposed ports of the container to create a secure tunnel
for the parent to access. This feature is used in the WildFly domain for the communication between the domain
controller and the hosts.</p>

<p>In order to setup and run the domain, you have to first start the domain controller. After that you can start as many
hosts as you like and link them to the domain controller. Be sure to use "dc" as name (using another name won't work):</p>

<pre><code>docker run -name wildfly-dc -d hpehl/wildfly-domain:dc
docker run -name hostA -link wildfly-dc:dc -d hpehl/wildfly-domain:hostA
docker run -name hostB -link wildfly-dc:dc -d hpehl/wildfly-domain:hostB
docker run -name hostC -link wildfly-dc:dc -d hpehl/wildfly-domain:hostC
docker run -name hostD -link wildfly-dc:dc -d hpehl/wildfly-domain:hostD
</code></pre>

<p>Some notes:</p>

<ul>
<li>The domain controller exposes the standard ports

<ul>
<li>8080 for HTTP</li>
<li>9990 for HTTP based management and</li>
<li>9999 for native management</li>
</ul>
</li>
<li>The hosts expose just port 8080</li>
<li>The domain controller defines the user <code>admin:passw0rd_</code>, which can be used for management</li>
</ul>


<h1>Troubleshooting</h1>

<p>Unfortunately in the current WildFly Beta there's a problem if you want to access the admin console of a WildFly
instance running inside a Docker container. I assume this will be fixed once WildFly GA is available. For the time
being you can only use the CLI.</p>

<p>If you need the console, you can use for instance EAP 6.2 which is not affected by this
limitation. You can find <a href="https://github.com/hpehl/dockerfiles/tree/master/eap62">Dockerfiles</a> on my GitHub account
using EAP. However please note that there's no EAP distribution included. You have to provide one on your own.</p>

<h1>Summary</h1>

<p>Using Docker it is really easy to setup a WildFly domain. Adding / removing hosts is just a matter of
starting / stopping Docker containers.</p>

<p>Docker offers also a rich API. So setting up your domain could also be done using a nifty web front-end where you
'click together' your server groups, hosts and servers. The Dockerfiles, images and containers would then be created
based on your input - all fully automatically!</p>

<h1>Resources</h1>

<ul>
<li>WildFly repositories on index.docker.io: https://index.docker.io/u/hpehl/</li>
<li>Related Dockerfiles: https://github.com/hpehl/dockerfiles/tree/master/wildfly</li>
</ul>

]]></content>
  </entry>
  
</feed>
